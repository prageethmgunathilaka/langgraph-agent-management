{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Structure and Dependencies",
        "description": "Initialize the project structure and install necessary dependencies for LangGraph agent management system",
        "details": "1. Create a new Python project with appropriate directory structure\n2. Install required dependencies:\n   - langchain==0.1.0 or newer\n   - langgraph==0.0.15 or newer (latest version recommended)\n   - fastapi==0.104.0 or newer for API endpoints\n   - pydantic==2.4.2 or newer for data validation\n   - uvicorn for serving the API\n   - pytest for testing\n3. Set up configuration management using environment variables\n4. Create basic project structure:\n   ```\n   /\n   ├── app/\n   │   ├── __init__.py\n   │   ├── main.py\n   │   ├── api/\n   │   │   ├── __init__.py\n   │   │   └── routes.py\n   │   ├── models/\n   │   │   ├── __init__.py\n   │   │   └── schemas.py\n   │   ├── services/\n   │   │   ├── __init__.py\n   │   │   ├── workflow_service.py\n   │   │   └── agent_service.py\n   │   └── utils/\n   │       ├── __init__.py\n   │       └── helpers.py\n   ├── tests/\n   │   ├── __init__.py\n   │   ├── test_workflow.py\n   │   └── test_agent.py\n   ├── requirements.txt\n   └── README.md\n   ```\n4. Configure logging system\n5. Set up error handling framework",
        "testStrategy": "1. Verify project structure is correctly set up\n2. Ensure all dependencies can be installed without conflicts\n3. Validate environment variable loading\n4. Test logging configuration\n5. Run basic smoke tests to ensure the application can start",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Project Directory Structure",
            "description": "Set up the initial project directory structure with all necessary folders and files",
            "dependencies": [],
            "details": "Create the following directory structure:\n- app/ directory with __init__.py and main.py\n- app/api/ with __init__.py and routes.py\n- app/models/ with __init__.py and schemas.py\n- app/services/ with __init__.py, workflow_service.py, and agent_service.py\n- app/utils/ with __init__.py and helpers.py\n- tests/ directory with __init__.py, test_workflow.py, and test_agent.py\n- Create empty README.md file at root level",
            "status": "done",
            "testStrategy": "Verify all directories and files exist in the correct structure using filesystem checks"
          },
          {
            "id": 2,
            "title": "Install and Configure Dependencies",
            "description": "Install all required Python packages and set up dependency management",
            "dependencies": [
              1
            ],
            "details": "Create requirements.txt file with the following dependencies:\n- langchain==0.1.0 or newer\n- langgraph==0.0.15 or newer\n- fastapi==0.104.0 or newer\n- pydantic==2.4.2 or newer\n- uvicorn\n- pytest\n- python-dotenv\n\nInstall all dependencies using pip install -r requirements.txt\nVerify installation by importing each package in a Python shell",
            "status": "done",
            "testStrategy": "Run pip freeze to confirm all packages are installed with correct versions; create a simple test script that imports all packages to verify they load without errors"
          },
          {
            "id": 3,
            "title": "Set Up Configuration Management",
            "description": "Implement environment variable loading and configuration management",
            "dependencies": [
              1,
              2
            ],
            "details": "Create a .env file template with required configuration variables\nImplement config.py in app/utils/ to load environment variables using python-dotenv\nDefine configuration classes for different environments (development, testing, production)\nImplement functions to validate configuration values\nCreate a .env.example file with sample values for documentation",
            "status": "done",
            "testStrategy": "Create test cases that verify environment variables are correctly loaded; test with missing variables to ensure proper error handling; verify different environment configurations load correctly"
          },
          {
            "id": 4,
            "title": "Configure Logging System",
            "description": "Set up a comprehensive logging system for the application",
            "dependencies": [
              1,
              3
            ],
            "details": "Create logger.py in app/utils/\nImplement logging configuration with different log levels\nSet up log formatting with timestamps, log levels, and source information\nConfigure log output to both console and file\nImplement log rotation to prevent large log files\nCreate utility functions for easy logging across the application",
            "status": "done",
            "testStrategy": "Test logging at different levels; verify log files are created correctly; check log rotation works; ensure log format includes all required information"
          },
          {
            "id": 5,
            "title": "Implement Error Handling Framework",
            "description": "Develop a consistent error handling system across the application",
            "dependencies": [
              1,
              3,
              4
            ],
            "details": "Create errors.py in app/utils/ to define custom exception classes\nImplement exception middleware for FastAPI to catch and format errors\nCreate error response models in app/models/schemas.py\nImplement utility functions for standardized error handling\nEnsure all errors are properly logged\nCreate documentation for error codes and their meanings",
            "status": "done",
            "testStrategy": "Test error handling by triggering various exceptions; verify correct HTTP status codes are returned; check error responses match the defined schema; ensure errors are properly logged with appropriate context"
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Workflow Management",
        "description": "Develop functionality to create and delete workflows identified by workflow ID",
        "details": "1. Create Pydantic models for workflow:\n```python\nclass Workflow(BaseModel):\n    id: str\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n    agents: Dict[str, Any] = Field(default_factory=dict)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n```\n\n2. Implement WorkflowService class with methods:\n```python\nclass WorkflowService:\n    def __init__(self):\n        self.workflows = {}\n        \n    def create_workflow(self, workflow_id: str, metadata: Optional[Dict[str, Any]] = None) -> Workflow:\n        \"\"\"Create a new workflow with the given ID\"\"\"\n        if workflow_id in self.workflows:\n            raise ValueError(f\"Workflow with ID {workflow_id} already exists\")\n            \n        workflow = Workflow(id=workflow_id, metadata=metadata or {})\n        self.workflows[workflow_id] = workflow\n        return workflow\n        \n    def get_workflow(self, workflow_id: str) -> Workflow:\n        \"\"\"Get workflow by ID\"\"\"\n        if workflow_id not in self.workflows:\n            raise ValueError(f\"Workflow with ID {workflow_id} not found\")\n            \n        return self.workflows[workflow_id]\n        \n    def delete_workflow(self, workflow_id: str) -> None:\n        \"\"\"Delete workflow by ID\"\"\"\n        if workflow_id not in self.workflows:\n            raise ValueError(f\"Workflow with ID {workflow_id} not found\")\n            \n        del self.workflows[workflow_id]\n```\n\n3. Create API endpoints for workflow management:\n```python\n@router.post(\"/workflows\", response_model=WorkflowResponse)\ndef create_workflow(workflow: WorkflowCreate):\n    return workflow_service.create_workflow(workflow.id, workflow.metadata)\n    \n@router.get(\"/workflows/{workflow_id}\", response_model=WorkflowResponse)\ndef get_workflow(workflow_id: str):\n    return workflow_service.get_workflow(workflow_id)\n    \n@router.delete(\"/workflows/{workflow_id}\")\ndef delete_workflow(workflow_id: str):\n    workflow_service.delete_workflow(workflow_id)\n    return {\"message\": f\"Workflow {workflow_id} deleted successfully\"}\n```\n\n4. Implement persistence mechanism (in-memory for initial version, can be extended to database later)",
        "testStrategy": "1. Unit tests for WorkflowService:\n   - Test creating workflows with valid and invalid IDs\n   - Test retrieving workflows\n   - Test deleting workflows\n2. API tests:\n   - Test workflow creation endpoint\n   - Test workflow retrieval endpoint\n   - Test workflow deletion endpoint\n3. Edge cases:\n   - Test creating duplicate workflows\n   - Test deleting non-existent workflows",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Agent Creation and Management",
        "description": "Develop functionality to create LangGraph agent nodes and add them to workflows",
        "details": "1. Create Pydantic models for agents:\n```python\nclass AgentType(str, Enum):\n    MAIN = \"main\"\n    CHILD = \"child\"\n\nclass AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    RUNNING = \"running\"\n    ERROR = \"error\"\n\nclass Agent(BaseModel):\n    id: str\n    workflow_id: str\n    type: AgentType\n    status: AgentStatus = AgentStatus.IDLE\n    model_config: Dict[str, Any]\n    connections: List[str] = Field(default_factory=list)\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n    metadata: Dict[str, Any] = Field(default_factory=dict)\n    max_child_agents: Optional[int] = None\n```\n\n2. Implement AgentService class with methods:\n```python\nclass AgentService:\n    def __init__(self, workflow_service: WorkflowService):\n        self.workflow_service = workflow_service\n        \n    def create_agent(self, workflow_id: str, agent_id: str, agent_type: AgentType, \n                     model_config: Dict[str, Any], max_child_agents: Optional[int] = None,\n                     metadata: Optional[Dict[str, Any]] = None) -> Agent:\n        \"\"\"Create a new agent and add it to the specified workflow\"\"\"\n        workflow = self.workflow_service.get_workflow(workflow_id)\n        \n        if agent_id in workflow.agents:\n            raise ValueError(f\"Agent with ID {agent_id} already exists in workflow {workflow_id}\")\n            \n        agent = Agent(\n            id=agent_id,\n            workflow_id=workflow_id,\n            type=agent_type,\n            model_config=model_config,\n            metadata=metadata or {},\n            max_child_agents=max_child_agents\n        )\n        \n        workflow.agents[agent_id] = agent\n        workflow.updated_at = datetime.now()\n        return agent\n        \n    def get_agent(self, workflow_id: str, agent_id: str) -> Agent:\n        \"\"\"Get agent by ID from the specified workflow\"\"\"\n        workflow = self.workflow_service.get_workflow(workflow_id)\n        \n        if agent_id not in workflow.agents:\n            raise ValueError(f\"Agent with ID {agent_id} not found in workflow {workflow_id}\")\n            \n        return workflow.agents[agent_id]\n        \n    def delete_agent(self, workflow_id: str, agent_id: str) -> None:\n        \"\"\"Delete agent by ID from the specified workflow\"\"\"\n        workflow = self.workflow_service.get_workflow(workflow_id)\n        \n        if agent_id not in workflow.agents:\n            raise ValueError(f\"Agent with ID {agent_id} not found in workflow {workflow_id}\")\n            \n        # Remove connections to this agent from other agents\n        for other_agent_id, other_agent in workflow.agents.items():\n            if agent_id in other_agent.connections:\n                other_agent.connections.remove(agent_id)\n                \n        del workflow.agents[agent_id]\n        workflow.updated_at = datetime.now()\n        \n    def list_agents(self, workflow_id: str) -> List[Agent]:\n        \"\"\"List all agents in the specified workflow\"\"\"\n        workflow = self.workflow_service.get_workflow(workflow_id)\n        return list(workflow.agents.values())\n```\n\n3. Create API endpoints for agent management:\n```python\n@router.post(\"/workflows/{workflow_id}/agents\", response_model=AgentResponse)\ndef create_agent(workflow_id: str, agent: AgentCreate):\n    return agent_service.create_agent(\n        workflow_id=workflow_id,\n        agent_id=agent.id,\n        agent_type=agent.type,\n        model_config=agent.model_config,\n        max_child_agents=agent.max_child_agents,\n        metadata=agent.metadata\n    )\n    \n@router.get(\"/workflows/{workflow_id}/agents/{agent_id}\", response_model=AgentResponse)\ndef get_agent(workflow_id: str, agent_id: str):\n    return agent_service.get_agent(workflow_id, agent_id)\n    \n@router.delete(\"/workflows/{workflow_id}/agents/{agent_id}\")\ndef delete_agent(workflow_id: str, agent_id: str):\n    agent_service.delete_agent(workflow_id, agent_id)\n    return {\"message\": f\"Agent {agent_id} deleted successfully\"}\n    \n@router.get(\"/workflows/{workflow_id}/agents\", response_model=List[AgentResponse])\ndef list_agents(workflow_id: str):\n    return agent_service.list_agents(workflow_id)\n```\n\n4. Implement integration with LangGraph for agent creation:\n```python\ndef create_langgraph_agent(agent_config: Dict[str, Any]) -> Any:\n    \"\"\"Create a LangGraph agent based on configuration\"\"\"\n    # This is a simplified example - actual implementation will depend on LangGraph API\n    from langgraph.graph import StateGraph\n    from langchain.chat_models import ChatOpenAI\n    \n    # Configure the LLM based on agent_config\n    llm = ChatOpenAI(**agent_config.get(\"llm_config\", {}))\n    \n    # Create a simple agent\n    builder = StateGraph()\n    # Add nodes and edges based on agent_config\n    # ...\n    \n    # Compile the graph\n    graph = builder.compile()\n    return graph\n```",
        "testStrategy": "1. Unit tests for AgentService:\n   - Test creating agents with valid and invalid parameters\n   - Test retrieving agents\n   - Test deleting agents\n   - Test listing agents in a workflow\n2. API tests:\n   - Test agent creation endpoint\n   - Test agent retrieval endpoint\n   - Test agent deletion endpoint\n   - Test agent listing endpoint\n3. Integration tests:\n   - Test creating actual LangGraph agents with different configurations\n   - Verify agent functionality with simple prompts\n4. Edge cases:\n   - Test creating duplicate agents\n   - Test deleting non-existent agents",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Agent Connection Management",
        "description": "Develop functionality to connect agent nodes to other agents, enabling delegation and task spawning through internal service method calls within the existing AgentService",
        "status": "in-progress",
        "dependencies": [
          3
        ],
        "priority": "medium",
        "details": "1. Extend existing AgentService class with connection management methods:\n```python\nclass AgentService:\n    # ... existing methods ...\n    \n    def connect_agents(self, workflow_id: str, source_agent_id: str, target_agent_id: str) -> None:\n        \"\"\"Connect source agent to target agent via internal method call\"\"\"\n        workflow = self.workflow_service.get_workflow(workflow_id)\n        \n        if source_agent_id not in workflow.agents:\n            raise ValueError(f\"Source agent {source_agent_id} not found in workflow {workflow_id}\")\n            \n        if target_agent_id not in workflow.agents:\n            raise ValueError(f\"Target agent {target_agent_id} not found in workflow {workflow_id}\")\n            \n        # Validate connection (prevent circular dependencies)\n        if self._would_create_cycle(workflow_id, source_agent_id, target_agent_id):\n            raise ValueError(f\"Connection would create circular dependency\")\n            \n        source_agent = workflow.agents[source_agent_id]\n        \n        if target_agent_id not in source_agent.connections:\n            source_agent.connections.append(target_agent_id)\n            source_agent.updated_at = datetime.now()\n            \n        workflow.updated_at = datetime.now()\n        \n        # Log connection event\n        self._log_connection_event(workflow_id, source_agent_id, target_agent_id, \"connected\")\n        \n    def disconnect_agents(self, workflow_id: str, source_agent_id: str, target_agent_id: str) -> None:\n        \"\"\"Disconnect source agent from target agent via internal method call\"\"\"\n        workflow = self.workflow_service.get_workflow(workflow_id)\n        \n        if source_agent_id not in workflow.agents:\n            raise ValueError(f\"Source agent {source_agent_id} not found in workflow {workflow_id}\")\n            \n        source_agent = workflow.agents[source_agent_id]\n        \n        if target_agent_id in source_agent.connections:\n            source_agent.connections.remove(target_agent_id)\n            source_agent.updated_at = datetime.now()\n            \n        workflow.updated_at = datetime.now()\n        \n        # Log disconnection event\n        self._log_connection_event(workflow_id, source_agent_id, target_agent_id, \"disconnected\")\n        \n    def get_connected_agents(self, workflow_id: str, agent_id: str) -> List[Agent]:\n        \"\"\"Get all agents connected to the specified agent\"\"\"\n        workflow = self.workflow_service.get_workflow(workflow_id)\n        \n        if agent_id not in workflow.agents:\n            raise ValueError(f\"Agent {agent_id} not found in workflow {workflow_id}\")\n            \n        agent = workflow.agents[agent_id]\n        connected_agents = []\n        \n        for connected_agent_id in agent.connections:\n            if connected_agent_id in workflow.agents:\n                connected_agents.append(workflow.agents[connected_agent_id])\n                \n        return connected_agents\n```\n\n2. Implement task delegation functionality within AgentService:\n```python\n    def delegate_task(self, workflow_id: str, source_agent_id: str, target_agent_id: str, \n                     task_data: Dict[str, Any]) -> str:\n        \"\"\"Delegate task from source agent to target agent\"\"\"\n        # Validate connection exists\n        workflow = self.workflow_service.get_workflow(workflow_id)\n        source_agent = workflow.agents[source_agent_id]\n        \n        if target_agent_id not in source_agent.connections:\n            raise ValueError(f\"No connection exists between {source_agent_id} and {target_agent_id}\")\n            \n        # Create task delegation record\n        task_id = str(uuid.uuid4())\n        delegation_record = {\n            \"task_id\": task_id,\n            \"source_agent_id\": source_agent_id,\n            \"target_agent_id\": target_agent_id,\n            \"task_data\": task_data,\n            \"status\": \"delegated\",\n            \"created_at\": datetime.now()\n        }\n        \n        # Store delegation record in workflow metadata\n        if \"delegated_tasks\" not in workflow.metadata:\n            workflow.metadata[\"delegated_tasks\"] = {}\n        workflow.metadata[\"delegated_tasks\"][task_id] = delegation_record\n        \n        # Log delegation event\n        self._log_delegation_event(workflow_id, source_agent_id, target_agent_id, task_id)\n        \n        return task_id\n        \n    def spawn_child_task(self, workflow_id: str, parent_agent_id: str, child_agent_id: str, \n                        task_data: Dict[str, Any]) -> str:\n        \"\"\"Spawn child task from parent agent to child agent\"\"\"\n        # Validate parent-child relationship\n        workflow = self.workflow_service.get_workflow(workflow_id)\n        parent_agent = workflow.agents[parent_agent_id]\n        child_agent = workflow.agents[child_agent_id]\n        \n        if parent_agent.type != AgentType.MAIN:\n            raise ValueError(f\"Only main agents can spawn child tasks\")\n            \n        if child_agent.type != AgentType.CHILD:\n            raise ValueError(f\"Tasks can only be spawned to child agents\")\n            \n        # Check child agent limit\n        current_children = len([aid for aid in parent_agent.connections \n                              if workflow.agents[aid].type == AgentType.CHILD])\n        if current_children >= parent_agent.model_config.get(\"max_child_agents\", 5):\n            raise ValueError(f\"Parent agent has reached maximum child agent limit\")\n            \n        return self.delegate_task(workflow_id, parent_agent_id, child_agent_id, task_data)\n        \n    def notify_task_completion(self, workflow_id: str, task_id: str, result: Dict[str, Any]) -> None:\n        \"\"\"Notify task completion and update delegation record\"\"\"\n        workflow = self.workflow_service.get_workflow(workflow_id)\n        \n        if \"delegated_tasks\" not in workflow.metadata or task_id not in workflow.metadata[\"delegated_tasks\"]:\n            raise ValueError(f\"Task {task_id} not found in workflow {workflow_id}\")\n            \n        delegation_record = workflow.metadata[\"delegated_tasks\"][task_id]\n        delegation_record[\"status\"] = \"completed\"\n        delegation_record[\"result\"] = result\n        delegation_record[\"completed_at\"] = datetime.now()\n        \n        # Log completion event\n        self._log_completion_event(workflow_id, delegation_record[\"target_agent_id\"], task_id)\n```\n\n3. Implement status communication methods within AgentService:\n```python\n    def update_agent_status(self, workflow_id: str, agent_id: str, status: AgentStatus, \n                           metadata: Optional[Dict[str, Any]] = None) -> None:\n        \"\"\"Update agent status via internal method call\"\"\"\n        workflow = self.workflow_service.get_workflow(workflow_id)\n        \n        if agent_id not in workflow.agents:\n            raise ValueError(f\"Agent {agent_id} not found in workflow {workflow_id}\")\n            \n        agent = workflow.agents[agent_id]\n        old_status = agent.status\n        agent.status = status\n        agent.updated_at = datetime.now()\n        \n        if metadata:\n            agent.metadata.update(metadata)\n            \n        # Broadcast status change to connected agents\n        self.broadcast_status_change(workflow_id, agent_id, old_status, status)\n        \n        # Log status change event\n        self._log_status_change_event(workflow_id, agent_id, old_status, status)\n        \n    def broadcast_status_change(self, workflow_id: str, agent_id: str, \n                               old_status: AgentStatus, new_status: AgentStatus) -> None:\n        \"\"\"Broadcast status change to all connected agents\"\"\"\n        connected_agents = self.get_connected_agents(workflow_id, agent_id)\n        \n        for connected_agent in connected_agents:\n            # Update connected agent's metadata with status change notification\n            if \"status_notifications\" not in connected_agent.metadata:\n                connected_agent.metadata[\"status_notifications\"] = []\n                \n            notification = {\n                \"agent_id\": agent_id,\n                \"old_status\": old_status,\n                \"new_status\": new_status,\n                \"timestamp\": datetime.now()\n            }\n            \n            connected_agent.metadata[\"status_notifications\"].append(notification)\n            connected_agent.updated_at = datetime.now()\n```\n\n4. Implement connection validation and cycle detection within AgentService:\n```python\n    def _would_create_cycle(self, workflow_id: str, source_agent_id: str, target_agent_id: str) -> bool:\n        \"\"\"Check if connecting source to target would create a circular dependency\"\"\"\n        workflow = self.workflow_service.get_workflow(workflow_id)\n        \n        # Use DFS to detect if target_agent_id can reach source_agent_id\n        visited = set()\n        \n        def dfs(current_agent_id: str) -> bool:\n            if current_agent_id == source_agent_id:\n                return True\n            if current_agent_id in visited:\n                return False\n                \n            visited.add(current_agent_id)\n            \n            if current_agent_id in workflow.agents:\n                current_agent = workflow.agents[current_agent_id]\n                for connected_id in current_agent.connections:\n                    if dfs(connected_id):\n                        return True\n                        \n            return False\n            \n        return dfs(target_agent_id)\n        \n    def validate_connection_integrity(self, workflow_id: str) -> List[str]:\n        \"\"\"Validate all connections in workflow and return list of issues\"\"\"\n        workflow = self.workflow_service.get_workflow(workflow_id)\n        issues = []\n        \n        for agent_id, agent in workflow.agents.items():\n            # Check for broken connections\n            for connected_id in agent.connections:\n                if connected_id not in workflow.agents:\n                    issues.append(f\"Agent {agent_id} has connection to non-existent agent {connected_id}\")\n                    \n            # Check child agent limits for main agents\n            if agent.type == AgentType.MAIN:\n                child_count = len([cid for cid in agent.connections \n                                 if workflow.agents.get(cid, {}).get('type') == AgentType.CHILD])\n                max_children = agent.model_config.get(\"max_child_agents\", 5)\n                if child_count > max_children:\n                    issues.append(f\"Main agent {agent_id} exceeds child limit: {child_count}/{max_children}\")\n                    \n        return issues\n```\n\n5. Add event logging methods within AgentService:\n```python\n    def __init__(self, workflow_service):\n        self.workflow_service = workflow_service\n        self.events = []  # Internal event logging\n        \n    def _log_connection_event(self, workflow_id: str, source_agent_id: str, \n                             target_agent_id: str, action: str) -> None:\n        event = {\n            \"type\": \"connection\",\n            \"workflow_id\": workflow_id,\n            \"source_agent_id\": source_agent_id,\n            \"target_agent_id\": target_agent_id,\n            \"action\": action,\n            \"timestamp\": datetime.now()\n        }\n        self.events.append(event)\n        \n    def _log_delegation_event(self, workflow_id: str, source_agent_id: str, \n                             target_agent_id: str, task_id: str) -> None:\n        event = {\n            \"type\": \"delegation\",\n            \"workflow_id\": workflow_id,\n            \"source_agent_id\": source_agent_id,\n            \"target_agent_id\": target_agent_id,\n            \"task_id\": task_id,\n            \"timestamp\": datetime.now()\n        }\n        self.events.append(event)\n        \n    def _log_status_change_event(self, workflow_id: str, agent_id: str, \n                                old_status: str, new_status: str) -> None:\n        event = {\n            \"type\": \"status_change\",\n            \"workflow_id\": workflow_id,\n            \"agent_id\": agent_id,\n            \"old_status\": old_status,\n            \"new_status\": new_status,\n            \"timestamp\": datetime.now()\n        }\n        self.events.append(event)\n        \n    def _log_completion_event(self, workflow_id: str, agent_id: str, task_id: str) -> None:\n        event = {\n            \"type\": \"task_completion\",\n            \"workflow_id\": workflow_id,\n            \"agent_id\": agent_id,\n            \"task_id\": task_id,\n            \"timestamp\": datetime.now()\n        }\n        self.events.append(event)\n```",
        "testStrategy": "1. Unit tests for AgentService connection methods:\n   - Test connecting agents via internal method calls within AgentService\n   - Test disconnecting agents via internal method calls within AgentService\n   - Test retrieving connected agents from AgentService\n   - Test task delegation functionality within AgentService\n   - Test child task spawning within AgentService\n   - Test task completion notification within AgentService\n2. Status communication tests within AgentService:\n   - Test agent status updates via AgentService methods\n   - Test status change broadcasting within AgentService\n   - Test status notification delivery through AgentService\n3. Connection validation tests within AgentService:\n   - Test circular dependency detection in AgentService\n   - Test connection integrity validation in AgentService\n   - Test child agent limit enforcement in AgentService\n4. Event logging tests within AgentService:\n   - Test connection event logging in AgentService\n   - Test delegation event logging in AgentService\n   - Test status change event logging in AgentService\n5. Performance tests for centralized AgentService:\n   - Test internal method call performance within single service\n   - Test concurrent connection operations in AgentService\n   - Test large-scale agent network performance with centralized service\n6. Integration tests for AgentService:\n   - Test end-to-end task delegation flow within AgentService\n   - Test agent status propagation across connections in AgentService\n   - Test workflow-level connection management through AgentService\n7. Edge cases for centralized AgentService:\n   - Test connecting non-existent agents via AgentService\n   - Test disconnecting non-connected agents via AgentService\n   - Test delegating tasks without proper connections in AgentService\n   - Test spawning tasks beyond child limits in AgentService\n   - Test circular connection prevention in AgentService",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Agent Status Tracking",
        "description": "Develop functionality to track agent status, connections, and basic details",
        "details": "1. Extend Agent model with status tracking:\n```python\nclass AgentStatus(str, Enum):\n    IDLE = \"idle\"\n    INITIALIZING = \"initializing\"\n    RUNNING = \"running\"\n    WAITING = \"waiting\"\n    COMPLETED = \"completed\"\n    ERROR = \"error\"\n\nclass AgentStats(BaseModel):\n    tasks_created: int = 0\n    tasks_completed: int = 0\n    child_agents_created: int = 0\n    last_active: Optional[datetime] = None\n    error_count: int = 0\n    token_usage: int = 0\n\nclass Agent(BaseModel):\n    # ... existing fields ...\n    status: AgentStatus = AgentStatus.IDLE\n    stats: AgentStats = Field(default_factory=AgentStats)\n    last_error: Optional[str] = None\n```\n\n2. Implement status update methods in AgentService:\n```python\ndef update_agent_status(self, workflow_id: str, agent_id: str, status: AgentStatus, \n                       error: Optional[str] = None) -> Agent:\n    \"\"\"Update agent status\"\"\"\n    agent = self.get_agent(workflow_id, agent_id)\n    agent.status = status\n    agent.updated_at = datetime.now()\n    \n    if status == AgentStatus.ERROR and error:\n        agent.last_error = error\n        agent.stats.error_count += 1\n    \n    if status in [AgentStatus.RUNNING, AgentStatus.WAITING]:\n        agent.stats.last_active = datetime.now()\n        \n    return agent\n    \ndef update_agent_stats(self, workflow_id: str, agent_id: str, \n                      stats_update: Dict[str, Any]) -> Agent:\n    \"\"\"Update agent statistics\"\"\"\n    agent = self.get_agent(workflow_id, agent_id)\n    \n    for key, value in stats_update.items():\n        if hasattr(agent.stats, key):\n            current_value = getattr(agent.stats, key)\n            if isinstance(current_value, int) and isinstance(value, int):\n                setattr(agent.stats, key, current_value + value)\n            else:\n                setattr(agent.stats, key, value)\n    \n    agent.updated_at = datetime.now()\n    return agent\n```\n\n3. Create API endpoints for status tracking:\n```python\n@router.put(\"/workflows/{workflow_id}/agents/{agent_id}/status\", response_model=AgentResponse)\ndef update_agent_status(workflow_id: str, agent_id: str, status_update: AgentStatusUpdate):\n    return agent_service.update_agent_status(\n        workflow_id=workflow_id,\n        agent_id=agent_id,\n        status=status_update.status,\n        error=status_update.error\n    )\n    \n@router.put(\"/workflows/{workflow_id}/agents/{agent_id}/stats\", response_model=AgentResponse)\ndef update_agent_stats(workflow_id: str, agent_id: str, stats_update: AgentStatsUpdate):\n    return agent_service.update_agent_stats(\n        workflow_id=workflow_id,\n        agent_id=agent_id,\n        stats_update=stats_update.dict(exclude_unset=True)\n    )\n```\n\n4. Implement monitoring and reporting functionality:\n```python\ndef get_workflow_status(self, workflow_id: str) -> Dict[str, Any]:\n    \"\"\"Get overall status of a workflow\"\"\"\n    workflow = self.workflow_service.get_workflow(workflow_id)\n    agents = list(workflow.agents.values())\n    \n    status_counts = {status.value: 0 for status in AgentStatus}\n    for agent in agents:\n        status_counts[agent.status.value] += 1\n        \n    total_tasks_created = sum(agent.stats.tasks_created for agent in agents)\n    total_tasks_completed = sum(agent.stats.tasks_completed for agent in agents)\n    total_errors = sum(agent.stats.error_count for agent in agents)\n    total_token_usage = sum(agent.stats.token_usage for agent in agents)\n    \n    return {\n        \"workflow_id\": workflow_id,\n        \"agent_count\": len(agents),\n        \"status_counts\": status_counts,\n        \"total_tasks_created\": total_tasks_created,\n        \"total_tasks_completed\": total_tasks_completed,\n        \"total_errors\": total_errors,\n        \"total_token_usage\": total_token_usage,\n        \"completion_percentage\": (total_tasks_completed / total_tasks_created * 100) if total_tasks_created > 0 else 0\n    }\n```",
        "testStrategy": "1. Unit tests for status tracking:\n   - Test updating agent status\n   - Test updating agent statistics\n   - Test workflow status reporting\n2. API tests:\n   - Test status update endpoints\n   - Test stats update endpoints\n   - Test workflow status endpoint\n3. Integration tests:\n   - Test status updates during actual agent execution\n   - Verify statistics accumulation during workflow execution\n4. Edge cases:\n   - Test handling of invalid status values\n   - Test statistics updates with invalid values\n   - Test reporting with empty workflows",
        "priority": "medium",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Main Agent Task Delegation",
        "description": "Develop functionality for main agents to create task lists and delegate tasks to child agents",
        "details": "1. Create models for task delegation:\n```python\nclass Task(BaseModel):\n    id: str\n    description: str\n    status: str = \"pending\"\n    assigned_agent_id: Optional[str] = None\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n    result: Optional[Dict[str, Any]] = None\n\nclass TaskList(BaseModel):\n    workflow_id: str\n    parent_agent_id: str\n    tasks: Dict[str, Task] = Field(default_factory=dict)\n    created_at: datetime = Field(default_factory=datetime.now)\n    updated_at: datetime = Field(default_factory=datetime.now)\n```\n\n2. Implement task delegation service:\n```python\nclass TaskDelegationService:\n    def __init__(self, workflow_service: WorkflowService, agent_service: AgentService):\n        self.workflow_service = workflow_service\n        self.agent_service = agent_service\n        self.task_lists = {}\n        \n    def create_task_list(self, workflow_id: str, parent_agent_id: str) -> TaskList:\n        \"\"\"Create a new task list for a parent agent\"\"\"\n        # Validate workflow and agent exist\n        agent = self.agent_service.get_agent(workflow_id, parent_agent_id)\n        \n        # Only main agents can create task lists\n        if agent.type != AgentType.MAIN:\n            raise ValueError(f\"Only main agents can create task lists. Agent {parent_agent_id} is not a main agent.\")\n            \n        task_list_id = f\"{workflow_id}_{parent_agent_id}\"\n        \n        if task_list_id in self.task_lists:\n            return self.task_lists[task_list_id]\n            \n        task_list = TaskList(\n            workflow_id=workflow_id,\n            parent_agent_id=parent_agent_id\n        )\n        \n        self.task_lists[task_list_id] = task_list\n        return task_list\n        \n    def add_task(self, workflow_id: str, parent_agent_id: str, task_id: str, description: str) -> Task:\n        \"\"\"Add a task to a task list\"\"\"\n        task_list_id = f\"{workflow_id}_{parent_agent_id}\"\n        \n        if task_list_id not in self.task_lists:\n            self.create_task_list(workflow_id, parent_agent_id)\n            \n        task_list = self.task_lists[task_list_id]\n        \n        if task_id in task_list.tasks:\n            raise ValueError(f\"Task with ID {task_id} already exists in task list for agent {parent_agent_id}\")\n            \n        task = Task(\n            id=task_id,\n            description=description\n        )\n        \n        task_list.tasks[task_id] = task\n        task_list.updated_at = datetime.now()\n        \n        # Update agent stats\n        self.agent_service.update_agent_stats(\n            workflow_id=workflow_id,\n            agent_id=parent_agent_id,\n            stats_update={\"tasks_created\": 1}\n        )\n        \n        return task\n        \n    def assign_task(self, workflow_id: str, parent_agent_id: str, task_id: str, assigned_agent_id: str) -> Task:\n        \"\"\"Assign a task to a child agent\"\"\"\n        task_list_id = f\"{workflow_id}_{parent_agent_id}\"\n        \n        if task_list_id not in self.task_lists:\n            raise ValueError(f\"Task list for agent {parent_agent_id} not found\")\n            \n        task_list = self.task_lists[task_list_id]\n        \n        if task_id not in task_list.tasks:\n            raise ValueError(f\"Task with ID {task_id} not found in task list for agent {parent_agent_id}\")\n            \n        # Validate assigned agent exists and is connected to parent agent\n        parent_agent = self.agent_service.get_agent(workflow_id, parent_agent_id)\n        \n        if assigned_agent_id not in parent_agent.connections:\n            raise ValueError(f\"Agent {assigned_agent_id} is not connected to parent agent {parent_agent_id}\")\n            \n        task = task_list.tasks[task_id]\n        task.assigned_agent_id = assigned_agent_id\n        task.status = \"assigned\"\n        task.updated_at = datetime.now()\n        \n        return task\n        \n    def update_task_status(self, workflow_id: str, parent_agent_id: str, task_id: str, \n                          status: str, result: Optional[Dict[str, Any]] = None) -> Task:\n        \"\"\"Update task status and result\"\"\"\n        task_list_id = f\"{workflow_id}_{parent_agent_id}\"\n        \n        if task_list_id not in self.task_lists:\n            raise ValueError(f\"Task list for agent {parent_agent_id} not found\")\n            \n        task_list = self.task_lists[task_list_id]\n        \n        if task_id not in task_list.tasks:\n            raise ValueError(f\"Task with ID {task_id} not found in task list for agent {parent_agent_id}\")\n            \n        task = task_list.tasks[task_id]\n        task.status = status\n        task.updated_at = datetime.now()\n        \n        if result is not None:\n            task.result = result\n            \n        # Update agent stats if task is completed\n        if status == \"completed\":\n            self.agent_service.update_agent_stats(\n                workflow_id=workflow_id,\n                agent_id=parent_agent_id,\n                stats_update={\"tasks_completed\": 1}\n            )\n            \n        return task\n```\n\n3. Implement LangGraph integration for task delegation:\n```python\ndef create_task_delegation_prompt(agent_id: str, task_description: str) -> str:\n    \"\"\"Create a prompt for task delegation\"\"\"\n    return f\"\"\"You are agent {agent_id}. You have been assigned the following task:\n\n{task_description}\n\nPlease complete this task and provide your result in JSON format.\n\"\"\"\n\ndef execute_delegated_task(workflow_id: str, parent_agent_id: str, task_id: str, \n                         agent_graphs: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Execute a delegated task using LangGraph\"\"\"\n    task_service = TaskDelegationService(workflow_service, agent_service)\n    task = task_service.get_task(workflow_id, parent_agent_id, task_id)\n    \n    if not task.assigned_agent_id or task.assigned_agent_id not in agent_graphs:\n        raise ValueError(f\"Task {task_id} is not properly assigned or agent graph not found\")\n        \n    agent_graph = agent_graphs[task.assigned_agent_id]\n    prompt = create_task_delegation_prompt(task.assigned_agent_id, task.description)\n    \n    # Execute the task using LangGraph\n    # This is a simplified example - actual implementation will depend on LangGraph API\n    result = agent_graph.invoke({\"input\": prompt})\n    \n    # Update task status and result\n    task_service.update_task_status(\n        workflow_id=workflow_id,\n        parent_agent_id=parent_agent_id,\n        task_id=task_id,\n        status=\"completed\",\n        result=result\n    )\n    \n    return result\n```\n\n4. Create API endpoints for task delegation:\n```python\n@router.post(\"/workflows/{workflow_id}/agents/{parent_agent_id}/tasks\", response_model=TaskResponse)\ndef create_task(workflow_id: str, parent_agent_id: str, task: TaskCreate):\n    return task_delegation_service.add_task(\n        workflow_id=workflow_id,\n        parent_agent_id=parent_agent_id,\n        task_id=task.id,\n        description=task.description\n    )\n    \n@router.put(\"/workflows/{workflow_id}/agents/{parent_agent_id}/tasks/{task_id}/assign\", response_model=TaskResponse)\ndef assign_task(workflow_id: str, parent_agent_id: str, task_id: str, assignment: TaskAssignment):\n    return task_delegation_service.assign_task(\n        workflow_id=workflow_id,\n        parent_agent_id=parent_agent_id,\n        task_id=task_id,\n        assigned_agent_id=assignment.assigned_agent_id\n    )\n    \n@router.put(\"/workflows/{workflow_id}/agents/{parent_agent_id}/tasks/{task_id}/status\", response_model=TaskResponse)\ndef update_task_status(workflow_id: str, parent_agent_id: str, task_id: str, status_update: TaskStatusUpdate):\n    return task_delegation_service.update_task_status(\n        workflow_id=workflow_id,\n        parent_agent_id=parent_agent_id,\n        task_id=task_id,\n        status=status_update.status,\n        result=status_update.result\n    )\n```",
        "testStrategy": "1. Unit tests for task delegation:\n   - Test creating task lists\n   - Test adding tasks\n   - Test assigning tasks\n   - Test updating task status\n2. API tests:\n   - Test task creation endpoint\n   - Test task assignment endpoint\n   - Test task status update endpoint\n3. Integration tests:\n   - Test end-to-end task delegation flow\n   - Verify task execution with LangGraph agents\n4. Edge cases:\n   - Test task delegation with invalid agents\n   - Test task assignment to disconnected agents\n   - Test handling of failed tasks",
        "priority": "high",
        "dependencies": [
          3,
          4,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Child Agent Spawning",
        "description": "Develop functionality for main agents to spawn child agents with specified limits",
        "details": "1. Extend AgentService with child agent spawning methods:\n```python\ndef spawn_child_agent(self, workflow_id: str, parent_agent_id: str, child_agent_id: str, \n                    model_config: Dict[str, Any], metadata: Optional[Dict[str, Any]] = None) -> Agent:\n    \"\"\"Spawn a child agent from a parent agent\"\"\"\n    # Validate parent agent exists and is a main agent\n    parent_agent = self.get_agent(workflow_id, parent_agent_id)\n    \n    if parent_agent.type != AgentType.MAIN:\n        raise ValueError(f\"Only main agents can spawn child agents. Agent {parent_agent_id} is not a main agent.\")\n        \n    # Check if parent agent has reached its child agent limit\n    if parent_agent.max_child_agents is not None:\n        child_count = sum(1 for agent_id, agent in self.workflow_service.get_workflow(workflow_id).agents.items()\n                         if agent.type == AgentType.CHILD and parent_agent_id in agent.metadata.get(\"parent_ids\", []))\n                         \n        if child_count >= parent_agent.max_child_agents:\n            raise ValueError(f\"Parent agent {parent_agent_id} has reached its child agent limit of {parent_agent.max_child_agents}\")\n    \n    # Create child agent metadata\n    child_metadata = metadata or {}\n    child_metadata[\"parent_ids\"] = child_metadata.get(\"parent_ids\", []) + [parent_agent_id]\n    \n    # Create the child agent\n    child_agent = self.create_agent(\n        workflow_id=workflow_id,\n        agent_id=child_agent_id,\n        agent_type=AgentType.CHILD,\n        model_config=model_config,\n        metadata=child_metadata\n    )\n    \n    # Connect parent agent to child agent\n    self.connect_agents(workflow_id, parent_agent_id, child_agent_id)\n    \n    # Update parent agent stats\n    parent_agent.stats.child_agents_created += 1\n    parent_agent.updated_at = datetime.now()\n    \n    return child_agent\n```\n\n2. Implement LangGraph integration for child agent spawning:\n```python\ndef create_child_agent_reasoning_prompt(parent_agent_id: str, task_description: str) -> str:\n    \"\"\"Create a prompt for reasoning about child agent creation\"\"\"\n    return f\"\"\"You are agent {parent_agent_id}. You need to complete the following task:\n\n{task_description}\n\nTo complete this task efficiently, you should break it down into subtasks and determine what specialized child agents you need to create.\n\nFor each child agent, provide:\n1. A unique ID for the child agent\n2. A description of the child agent's purpose\n3. The specific subtask this child agent will handle\n4. Any specific capabilities or knowledge this child agent needs\n\nRespond in JSON format with an array of child agents you want to create.\n\"\"\"\n\ndef create_child_agents_from_reasoning(workflow_id: str, parent_agent_id: str, \n                                     task_description: str, agent_graphs: Dict[str, Any]) -> List[Agent]:\n    \"\"\"Create child agents based on parent agent's reasoning\"\"\"\n    parent_agent = agent_service.get_agent(workflow_id, parent_agent_id)\n    \n    # Get parent agent's graph\n    if parent_agent_id not in agent_graphs:\n        raise ValueError(f\"Agent graph for {parent_agent_id} not found\")\n        \n    parent_graph = agent_graphs[parent_agent_id]\n    \n    # Create reasoning prompt\n    prompt = create_child_agent_reasoning_prompt(parent_agent_id, task_description)\n    \n    # Execute reasoning using LangGraph\n    # This is a simplified example - actual implementation will depend on LangGraph API\n    reasoning_result = parent_graph.invoke({\"input\": prompt})\n    \n    # Parse the reasoning result to get child agent specifications\n    child_specs = reasoning_result.get(\"child_agents\", [])\n    \n    # Create child agents\n    created_agents = []\n    for spec in child_specs:\n        # Create a model configuration based on the child agent specification\n        model_config = {\n            \"llm_config\": {\n                \"model\": \"gpt-4\",  # Default model, can be customized based on spec\n                \"temperature\": 0.7\n            },\n            \"tools\": spec.get(\"tools\", []),\n            \"purpose\": spec.get(\"purpose\"),\n            \"capabilities\": spec.get(\"capabilities\", [])\n        }\n        \n        # Create the child agent\n        child_agent = agent_service.spawn_child_agent(\n            workflow_id=workflow_id,\n            parent_agent_id=parent_agent_id,\n            child_agent_id=spec[\"id\"],\n            model_config=model_config,\n            metadata={\n                \"purpose\": spec.get(\"purpose\"),\n                \"subtask\": spec.get(\"subtask\")\n            }\n        )\n        \n        # Create the child agent's LangGraph\n        child_graph = create_langgraph_agent(model_config)\n        agent_graphs[child_agent.id] = child_graph\n        \n        created_agents.append(child_agent)\n        \n    return created_agents\n```\n\n3. Create API endpoints for child agent spawning:\n```python\n@router.post(\"/workflows/{workflow_id}/agents/{parent_agent_id}/spawn\", response_model=AgentResponse)\ndef spawn_child_agent(workflow_id: str, parent_agent_id: str, child_agent: ChildAgentCreate):\n    return agent_service.spawn_child_agent(\n        workflow_id=workflow_id,\n        parent_agent_id=parent_agent_id,\n        child_agent_id=child_agent.id,\n        model_config=child_agent.model_config,\n        metadata=child_agent.metadata\n    )\n    \n@router.post(\"/workflows/{workflow_id}/agents/{parent_agent_id}/reason-and-spawn\", response_model=List[AgentResponse])\ndef reason_and_spawn_child_agents(workflow_id: str, parent_agent_id: str, task: TaskDescription):\n    return create_child_agents_from_reasoning(\n        workflow_id=workflow_id,\n        parent_agent_id=parent_agent_id,\n        task_description=task.description,\n        agent_graphs=agent_graphs  # This would be managed by the application\n    )\n```\n\n4. Implement child agent limit validation and tracking:\n```python\ndef get_child_agent_count(self, workflow_id: str, parent_agent_id: str) -> int:\n    \"\"\"Get the number of child agents spawned by a parent agent\"\"\"\n    workflow = self.workflow_service.get_workflow(workflow_id)\n    \n    return sum(1 for agent_id, agent in workflow.agents.items()\n              if agent.type == AgentType.CHILD and \n              parent_agent_id in agent.metadata.get(\"parent_ids\", []))\n              \ndef can_spawn_more_child_agents(self, workflow_id: str, parent_agent_id: str) -> bool:\n    \"\"\"Check if a parent agent can spawn more child agents\"\"\"\n    parent_agent = self.get_agent(workflow_id, parent_agent_id)\n    \n    if parent_agent.type != AgentType.MAIN:\n        return False\n        \n    if parent_agent.max_child_agents is None:\n        return True\n        \n    child_count = self.get_child_agent_count(workflow_id, parent_agent_id)\n    return child_count < parent_agent.max_child_agents\n```",
        "testStrategy": "1. Unit tests for child agent spawning:\n   - Test spawning child agents\n   - Test child agent limit enforcement\n   - Test parent-child relationship tracking\n2. API tests:\n   - Test spawn child agent endpoint\n   - Test reason and spawn endpoint\n3. Integration tests:\n   - Test end-to-end child agent spawning flow\n   - Verify reasoning-based child agent creation\n   - Test child agents' ability to complete assigned tasks\n4. Edge cases:\n   - Test spawning with invalid parent agents\n   - Test spawning beyond the child agent limit\n   - Test handling of reasoning failures",
        "priority": "high",
        "dependencies": [
          3,
          4,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Implement Resource Management and Monitoring",
        "description": "Develop functionality to monitor and manage resource usage, prevent memory issues, and handle token limits",
        "details": "1. Create resource monitoring models:\n```python\nclass ResourceUsage(BaseModel):\n    cpu_percent: float = 0.0\n    memory_percent: float = 0.0\n    active_agents: int = 0\n    token_usage: int = 0\n    timestamp: datetime = Field(default_factory=datetime.now)\n\nclass ResourceLimits(BaseModel):\n    max_agents_per_workflow: int = 50\n    max_token_usage_per_workflow: int = 1000000\n    max_memory_percent: float = 80.0\n    max_cpu_percent: float = 90.0\n```\n\n2. Implement resource monitoring service:\n```python\nclass ResourceMonitoringService:\n    def __init__(self, workflow_service: WorkflowService):\n        self.workflow_service = workflow_service\n        self.resource_usage_history = []\n        self.resource_limits = ResourceLimits()\n        \n    def get_current_resource_usage(self) -> ResourceUsage:\n        \"\"\"Get current resource usage\"\"\"\n        import psutil\n        \n        # Get system resource usage\n        cpu_percent = psutil.cpu_percent(interval=0.1)\n        memory_percent = psutil.virtual_memory().percent\n        \n        # Count active agents across all workflows\n        active_agents = 0\n        total_token_usage = 0\n        \n        for workflow_id, workflow in self.workflow_service.workflows.items():\n            for agent_id, agent in workflow.agents.items():\n                if agent.status in [AgentStatus.RUNNING, AgentStatus.WAITING]:\n                    active_agents += 1\n                total_token_usage += agent.stats.token_usage\n        \n        usage = ResourceUsage(\n            cpu_percent=cpu_percent,\n            memory_percent=memory_percent,\n            active_agents=active_agents,\n            token_usage=total_token_usage\n        )\n        \n        # Store usage history (limited to last 100 entries)\n        self.resource_usage_history.append(usage)\n        if len(self.resource_usage_history) > 100:\n            self.resource_usage_history.pop(0)\n            \n        return usage\n        \n    def check_resource_limits(self, workflow_id: str) -> Dict[str, Any]:\n        \"\"\"Check if resource usage is within limits\"\"\"\n        usage = self.get_current_resource_usage()\n        workflow = self.workflow_service.get_workflow(workflow_id)\n        \n        # Check workflow-specific limits\n        workflow_agent_count = len(workflow.agents)\n        workflow_token_usage = sum(agent.stats.token_usage for agent in workflow.agents.values())\n        \n        limits_exceeded = {\n            \"cpu_exceeded\": usage.cpu_percent > self.resource_limits.max_cpu_percent,\n            \"memory_exceeded\": usage.memory_percent > self.resource_limits.max_memory_percent,\n            \"agents_exceeded\": workflow_agent_count > self.resource_limits.max_agents_per_workflow,\n            \"tokens_exceeded\": workflow_token_usage > self.resource_limits.max_token_usage_per_workflow\n        }\n        \n        return {\n            \"current_usage\": usage,\n            \"workflow_agent_count\": workflow_agent_count,\n            \"workflow_token_usage\": workflow_token_usage,\n            \"limits\": self.resource_limits,\n            \"limits_exceeded\": limits_exceeded,\n            \"any_limit_exceeded\": any(limits_exceeded.values())\n        }\n        \n    def update_resource_limits(self, limits: ResourceLimits) -> ResourceLimits:\n        \"\"\"Update resource limits\"\"\"\n        self.resource_limits = limits\n        return self.resource_limits\n        \n    def get_resource_usage_history(self) -> List[ResourceUsage]:\n        \"\"\"Get resource usage history\"\"\"\n        return self.resource_usage_history\n```\n\n3. Implement token usage tracking in LangGraph integration:\n```python\ndef track_token_usage(workflow_id: str, agent_id: str, prompt_tokens: int, completion_tokens: int) -> None:\n    \"\"\"Track token usage for an agent\"\"\"\n    agent = agent_service.get_agent(workflow_id, agent_id)\n    \n    # Update token usage in agent stats\n    total_tokens = prompt_tokens + completion_tokens\n    agent_service.update_agent_stats(\n        workflow_id=workflow_id,\n        agent_id=agent_id,\n        stats_update={\"token_usage\": total_tokens}\n    )\n    \n    # Check if token usage exceeds limits\n    resource_check = resource_monitoring_service.check_resource_limits(workflow_id)\n    \n    if resource_check[\"limits_exceeded\"][\"tokens_exceeded\"]:\n        # Log warning about token usage\n        logger.warning(f\"Token usage limit exceeded for workflow {workflow_id}\")\n```\n\n4. Implement resource-aware agent execution:\n```python\ndef execute_agent_with_resource_check(workflow_id: str, agent_id: str, \n                                     input_data: Dict[str, Any], agent_graphs: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Execute an agent with resource usage checks\"\"\"\n    # Check resource limits before execution\n    resource_check = resource_monitoring_service.check_resource_limits(workflow_id)\n    \n    if resource_check[\"any_limit_exceeded\"]:\n        # Handle resource limit exceeded\n        exceeded_limits = [k for k, v in resource_check[\"limits_exceeded\"].items() if v]\n        error_message = f\"Cannot execute agent due to resource limits exceeded: {', '.join(exceeded_limits)}\"\n        \n        # Update agent status to error\n        agent_service.update_agent_status(\n            workflow_id=workflow_id,\n            agent_id=agent_id,\n            status=AgentStatus.ERROR,\n            error=error_message\n        )\n        \n        raise ResourceLimitExceededError(error_message)\n    \n    # Get agent graph\n    if agent_id not in agent_graphs:\n        raise ValueError(f\"Agent graph for {agent_id} not found\")\n        \n    agent_graph = agent_graphs[agent_id]\n    \n    # Update agent status to running\n    agent_service.update_agent_status(\n        workflow_id=workflow_id,\n        agent_id=agent_id,\n        status=AgentStatus.RUNNING\n    )\n    \n    try:\n        # Execute the agent\n        # This is a simplified example - actual implementation will depend on LangGraph API\n        result = agent_graph.invoke(input_data)\n        \n        # Track token usage\n        # In a real implementation, you would get these values from the LLM response\n        prompt_tokens = len(str(input_data)) // 4  # Rough estimate\n        completion_tokens = len(str(result)) // 4  # Rough estimate\n        \n        track_token_usage(workflow_id, agent_id, prompt_tokens, completion_tokens)\n        \n        # Update agent status to completed\n        agent_service.update_agent_status(\n            workflow_id=workflow_id,\n            agent_id=agent_id,\n            status=AgentStatus.COMPLETED\n        )\n        \n        return result\n        \n    except Exception as e:\n        # Update agent status to error\n        agent_service.update_agent_status(\n            workflow_id=workflow_id,\n            agent_id=agent_id,\n            status=AgentStatus.ERROR,\n            error=str(e)\n        )\n        \n        raise\n```\n\n5. Create API endpoints for resource monitoring:\n```python\n@router.get(\"/resources/usage\", response_model=ResourceUsageResponse)\ndef get_resource_usage():\n    return resource_monitoring_service.get_current_resource_usage()\n    \n@router.get(\"/resources/history\", response_model=List[ResourceUsageResponse])\ndef get_resource_usage_history():\n    return resource_monitoring_service.get_resource_usage_history()\n    \n@router.get(\"/workflows/{workflow_id}/resources\", response_model=ResourceCheckResponse)\ndef check_workflow_resources(workflow_id: str):\n    return resource_monitoring_service.check_resource_limits(workflow_id)\n    \n@router.put(\"/resources/limits\", response_model=ResourceLimitsResponse)\ndef update_resource_limits(limits: ResourceLimitsUpdate):\n    return resource_monitoring_service.update_resource_limits(limits)\n```",
        "testStrategy": "1. Unit tests for resource monitoring:\n   - Test resource usage tracking\n   - Test resource limit checking\n   - Test token usage tracking\n2. API tests:\n   - Test resource usage endpoints\n   - Test resource history endpoint\n   - Test resource limits update endpoint\n3. Integration tests:\n   - Test resource-aware agent execution\n   - Verify token usage tracking during workflow execution\n   - Test system behavior when resource limits are exceeded\n4. Load tests:\n   - Test system under high agent count\n   - Test system with high token usage\n   - Verify graceful degradation when resources are constrained",
        "priority": "medium",
        "dependencies": [
          3,
          5,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-14T19:14:27.725Z",
      "updated": "2025-07-16T16:09:53.848Z",
      "description": "Tasks for master context"
    }
  }
}